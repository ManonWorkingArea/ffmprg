<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Recording API Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <div class="max-w-4xl mx-auto">
            <!-- Header -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h1 class="text-3xl font-bold text-gray-800 mb-2">
                    <i class="fas fa-video text-blue-600 mr-3"></i>
                    Media Recording API Test
                </h1>
                <p class="text-gray-600">
                    à¸—à¸”à¸ªà¸­à¸š VideoChunkManager à¸ˆà¸£à¸´à¸‡à¹† à¸ªà¹ˆà¸‡ HTTP requests à¹„à¸›à¸¢à¸±à¸‡ media server endpoints
                </p>
                <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-blue-50 p-3 rounded-lg">
                        <div class="text-sm font-medium text-blue-800">Chunk Duration</div>
                        <div class="text-lg font-bold text-blue-600">5 à¸§à¸´à¸™à¸²à¸—à¸µ</div>
                    </div>
                    <div class="bg-green-50 p-3 rounded-lg">
                        <div class="text-sm font-medium text-green-800">Quality</div>
                        <div class="text-lg font-bold text-green-600">4K@60fps</div>
                    </div>
                    <div class="bg-purple-50 p-3 rounded-lg">
                        <div class="text-sm font-medium text-purple-800">Chunk Size</div>
                        <div class="text-lg font-bold text-purple-600">~12-15MB</div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">
                    <i class="fas fa-play-circle text-green-600 mr-2"></i>
                    Recording Controls
                </h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                    <button id="initSession" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                        <i class="fas fa-plus mr-2"></i>Init Session
                    </button>
                    <button id="uploadChunk" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200" disabled>
                        <i class="fas fa-upload mr-2"></i>Upload Chunk
                    </button>
                    <button id="finalizeSession" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200" disabled>
                        <i class="fas fa-check mr-2"></i>Finalize
                    </button>
                    <button id="clearLogs" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                        <i class="fas fa-trash mr-2"></i>Clear Logs
                    </button>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <button id="autoDemo" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                        <i class="fas fa-robot mr-2"></i>Auto Demo
                    </button>
                    <button id="performanceTest" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                        <i class="fas fa-tachometer-alt mr-2"></i>Performance Test
                    </button>
                    <button id="systemStatus" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                        <i class="fas fa-info-circle mr-2"></i>System Status
                    </button>
                </div>
            </div>

            <!-- Status -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">
                    <i class="fas fa-chart-line text-blue-600 mr-2"></i>
                    Session Status
                </h2>
                <div id="sessionStatus" class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-gray-400" id="sessionId">-</div>
                        <div class="text-sm text-gray-600">Session ID</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-gray-400" id="chunkCount">0</div>
                        <div class="text-sm text-gray-600">Chunks Uploaded</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-gray-400" id="totalSize">0 MB</div>
                        <div class="text-sm text-gray-600">Total Size</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-gray-400" id="sessionStatusText">Idle</div>
                        <div class="text-sm text-gray-600">Status</div>
                    </div>
                </div>
            </div>

            <!-- Network Activity -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">
                    <i class="fas fa-network-wired text-green-600 mr-2"></i>
                    Network Activity
                </h2>
                <div id="networkActivity" class="space-y-2 max-h-40 overflow-y-auto">
                    <div class="text-gray-500 text-center py-4">No network activity yet</div>
                </div>
            </div>

            <!-- Console Logs -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">
                    <i class="fas fa-terminal text-gray-700 mr-2"></i>
                    Console Logs
                </h2>
                <div id="consoleLogs" class="bg-gray-900 text-green-400 p-4 rounded-lg font-mono text-sm max-h-96 overflow-y-auto">
                    <div>ðŸŽ¬ VideoChunkManager Test Interface Loaded</div>
                    <div>ðŸ“¡ Ready for API testing...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class VideoChunkManagerTest {
            constructor() {
                this.apiBase = '/api/media';
                this.currentSession = null;
                this.chunkIndex = 0;
                this.totalSize = 0;
                this.networkRequests = [];
                
                this.initializeUI();
                this.log('ðŸŽ¬ VideoChunkManagerTest initialized');
                this.log('ðŸ“¡ API Base: ' + this.apiBase);
            }
            
            initializeUI() {
                document.getElementById('initSession').addEventListener('click', () => this.initSession());
                document.getElementById('uploadChunk').addEventListener('click', () => this.uploadChunk());
                document.getElementById('finalizeSession').addEventListener('click', () => this.finalizeSession());
                document.getElementById('clearLogs').addEventListener('click', () => this.clearLogs());
                document.getElementById('autoDemo').addEventListener('click', () => this.runAutoDemo());
                document.getElementById('performanceTest').addEventListener('click', () => this.runPerformanceTest());
                document.getElementById('systemStatus').addEventListener('click', () => this.getSystemStatus());
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('consoleLogs');
                const logEntry = document.createElement('div');
                logEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;
                logElement.appendChild(logEntry);
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            logNetwork(method, url, status, size = null) {
                const networkActivity = document.getElementById('networkActivity');
                const timestamp = new Date().toLocaleTimeString();
                
                // Clear placeholder
                if (networkActivity.innerHTML.includes('No network activity')) {
                    networkActivity.innerHTML = '';
                }
                
                const requestEntry = document.createElement('div');
                requestEntry.className = `flex justify-between items-center p-2 rounded-lg ${status >= 400 ? 'bg-red-50 text-red-800' : 'bg-green-50 text-green-800'}`;
                
                requestEntry.innerHTML = `
                    <div>
                        <span class="font-bold">${method}</span> ${url}
                        ${size ? `<span class="text-xs ml-2">(${size})</span>` : ''}
                    </div>
                    <div class="text-sm">
                        <span class="font-bold">Status: ${status}</span>
                        <span class="ml-2 text-xs">${timestamp}</span>
                    </div>
                `;
                
                networkActivity.insertBefore(requestEntry, networkActivity.firstChild);
                
                // Keep only last 10 entries
                while (networkActivity.children.length > 10) {
                    networkActivity.removeChild(networkActivity.lastChild);
                }
            }
            
            updateStatus() {
                if (this.currentSession) {
                    document.getElementById('sessionId').textContent = this.currentSession.sessionId.substring(0, 20) + '...';
                    document.getElementById('chunkCount').textContent = this.chunkIndex;
                    document.getElementById('totalSize').textContent = (this.totalSize / 1024 / 1024).toFixed(2) + ' MB';
                    document.getElementById('sessionStatusText').textContent = this.currentSession.status || 'Active';
                }
            }
            
            async initSession() {
                this.log('ðŸ“¡ Creating session with real HTTP request to dummy endpoint...');
                
                try {
                    const response = await fetch(`${this.apiBase}/recording/init`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sessionId: null,
                            timestamp: new Date().toISOString(),
                            dummyMode: true
                        })
                    });
                    
                    this.logNetwork('POST', '/api/media/recording/init', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.currentSession = data;
                        this.chunkIndex = 0;
                        this.totalSize = 0;
                        
                        this.log('âœ… Session created successfully');
                        this.log(`ðŸ“‹ Session ID: ${data.sessionId}`);
                        
                        // Enable chunk upload button
                        document.getElementById('uploadChunk').disabled = false;
                        document.getElementById('finalizeSession').disabled = false;
                        
                        this.updateStatus();
                        
                    } else {
                        this.log('ðŸ“¡ Real request sent, response status: ' + response.status);
                        this.log('ðŸ“¡ Real request failed as expected (no server): ' + response.statusText);
                        this.log('âœ… Dummy fallback session created');
                    }
                    
                } catch (error) {
                    this.log('ðŸ“¡ Real request failed as expected (no server): ' + error.message);
                    this.log('âœ… Dummy fallback session created');
                    
                    // Create dummy session
                    this.currentSession = {
                        sessionId: `rec_${Date.now()}_test123`,
                        status: 'initialized',
                        timestamp: new Date().toISOString()
                    };
                    
                    document.getElementById('uploadChunk').disabled = false;
                    document.getElementById('finalizeSession').disabled = false;
                    this.updateStatus();
                }
            }
            
            generateDummyChunk(sizeBytes) {
                // Create a realistic looking WebM chunk
                const chunk = new Uint8Array(sizeBytes);
                
                // Fill with semi-random data
                for (let i = 0; i < sizeBytes; i += 1024) {
                    const randomData = new TextEncoder().encode(Math.random().toString(36).substring(2, 15));
                    chunk.set(randomData, i);
                }
                
                return new Blob([chunk], { type: 'video/webm' });
            }
            
            async uploadChunk() {
                if (!this.currentSession) {
                    this.log('âŒ No session available. Please init session first.');
                    return;
                }
                
                const chunkSize = 12 * 1024 * 1024; // 12MB
                const chunkData = this.generateDummyChunk(chunkSize);
                
                this.log(`ðŸ“¤ Uploading chunk ${this.chunkIndex} with real HTTP request (${(chunkSize / 1024 / 1024).toFixed(2)}MB)...`);
                this.log('ðŸ“¡ Sending real FormData request to: /api/media/recording/chunk');
                
                try {
                    const formData = new FormData();
                    formData.append('chunk', chunkData, `chunk_${this.chunkIndex}.webm`);
                    formData.append('sessionId', this.currentSession.sessionId);
                    formData.append('chunkIndex', this.chunkIndex.toString());
                    formData.append('metadata', JSON.stringify({
                        sessionId: this.currentSession.sessionId,
                        chunkIndex: this.chunkIndex,
                        size: chunkSize,
                        timestamp: new Date().toISOString()
                    }));
                    formData.append('dummyMode', 'true');
                    
                    const response = await fetch(`${this.apiBase}/recording/chunk`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    this.logNetwork('POST', '/api/media/recording/chunk', response.status, `${(chunkSize / 1024 / 1024).toFixed(2)}MB`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.log(`âœ… Chunk ${this.chunkIndex} uploaded successfully`);
                        this.log(`ðŸ“ Server path: ${data.path}`);
                        
                        this.chunkIndex++;
                        this.totalSize += chunkSize;
                        this.updateStatus();
                        
                    } else {
                        this.log('ðŸ“¡ Real chunk request sent, response status: ' + response.status);
                        this.log('ðŸ“¡ Real chunk request failed as expected (no server): ' + response.statusText);
                        this.log(`âœ… Dummy fallback chunk ${this.chunkIndex} uploaded successfully`);
                        
                        this.chunkIndex++;
                        this.totalSize += chunkSize;
                        this.updateStatus();
                    }
                    
                } catch (error) {
                    this.log('ðŸ“¡ Real chunk request failed as expected (no server): ' + error.message);
                    this.log(`âœ… Dummy fallback chunk ${this.chunkIndex} uploaded successfully`);
                    
                    this.chunkIndex++;
                    this.totalSize += chunkSize;
                    this.updateStatus();
                }
            }
            
            async finalizeSession() {
                if (!this.currentSession || this.chunkIndex === 0) {
                    this.log('âŒ No session or chunks available for finalization.');
                    return;
                }
                
                this.log('ðŸ Finalizing with real HTTP request to dummy endpoint');
                
                try {
                    const response = await fetch(`${this.apiBase}/recording/finalize`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sessionId: this.currentSession.sessionId,
                            totalChunks: this.chunkIndex,
                            totalSize: this.totalSize,
                            dummyMode: true
                        })
                    });
                    
                    this.logNetwork('POST', '/api/media/recording/finalize', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.log('âœ… Session finalized successfully');
                        this.log(`ðŸŽ¥ Final video URL: ${data.finalVideoUrl}`);
                        this.log(`ðŸ“Š Total chunks: ${data.totalChunks}, Total size: ${data.totalSizeMB}MB`);
                        
                        this.currentSession.status = 'completed';
                        this.updateStatus();
                        
                    } else {
                        this.log('ðŸ“¡ Real finalize request sent, response status: ' + response.status);
                        this.log('ðŸ“¡ Real finalize request failed as expected (no server): ' + response.statusText);
                        this.log('âœ… Dummy fallback session finalized');
                        
                        this.currentSession.status = 'completed';
                        this.updateStatus();
                    }
                    
                } catch (error) {
                    this.log('ðŸ“¡ Real finalize request failed as expected (no server): ' + error.message);
                    this.log('âœ… Dummy fallback session finalized');
                    
                    this.currentSession.status = 'completed';
                    this.updateStatus();
                }
            }
            
            async runAutoDemo() {
                this.log('ðŸ¤– Starting automatic demo...');
                
                // Step 1: Init session
                await this.initSession();
                await this.delay(1000);
                
                // Step 2: Upload multiple chunks
                for (let i = 0; i < 5; i++) {
                    this.log(`ðŸ¤– Auto uploading chunk ${i + 1}/5...`);
                    await this.uploadChunk();
                    await this.delay(500);
                }
                
                // Step 3: Finalize
                await this.delay(1000);
                await this.finalizeSession();
                
                this.log('ðŸ¤– Automatic demo completed!');
            }
            
            async runPerformanceTest() {
                this.log('ðŸš€ Starting performance test...');
                
                await this.initSession();
                await this.delay(500);
                
                const startTime = Date.now();
                const chunkCount = 10;
                
                // Upload chunks in parallel
                const uploadPromises = [];
                for (let i = 0; i < chunkCount; i++) {
                    uploadPromises.push(this.uploadChunkAsync(i));
                    await this.delay(100); // Slight delay between starts
                }
                
                await Promise.all(uploadPromises);
                
                const endTime = Date.now();
                const totalTime = endTime - startTime;
                const totalSizeMB = (chunkCount * 12);
                const throughputMBps = totalSizeMB / (totalTime / 1000);
                
                this.log(`ðŸ“Š Performance test completed in ${totalTime}ms`);
                this.log(`ðŸ“Š Total data: ${totalSizeMB}MB`);
                this.log(`ðŸ“Š Throughput: ${throughputMBps.toFixed(2)}MB/s`);
                this.log(`ðŸ“Š Average per chunk: ${(totalTime / chunkCount).toFixed(2)}ms`);
                
                await this.finalizeSession();
            }
            
            async uploadChunkAsync(index) {
                const chunkSize = 12 * 1024 * 1024;
                const chunkData = this.generateDummyChunk(chunkSize);
                
                try {
                    const formData = new FormData();
                    formData.append('chunk', chunkData, `perf_chunk_${index}.webm`);
                    formData.append('sessionId', this.currentSession.sessionId);
                    formData.append('chunkIndex', index.toString());
                    formData.append('dummyMode', 'true');
                    
                    const startTime = Date.now();
                    
                    const response = await fetch(`${this.apiBase}/recording/chunk`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const uploadTime = Date.now() - startTime;
                    this.log(`   Chunk ${index}: ${uploadTime}ms`);
                    
                    return { index, uploadTime, success: true };
                    
                } catch (error) {
                    return { index, error: error.message, success: false };
                }
            }
            
            async getSystemStatus() {
                this.log('ðŸ“Š Fetching system status...');
                
                try {
                    const response = await fetch(`${this.apiBase}/recording/status`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.log('âœ… System status retrieved:');
                        this.log(`   Sessions: ${data.sessions.total} (${data.sessions.active} active)`);
                        this.log(`   Chunks: ${data.chunks.total} (${data.chunks.totalSizeMB}MB)`);
                        this.log(`   Mode: ${data.system.mode}`);
                        this.log(`   Configuration: ${data.configuration.chunkDurationMs}ms chunks, ${data.configuration.videoBitsPerSecond/1000000}Mbps`);
                    } else {
                        this.log('âŒ Failed to get system status: ' + response.status);
                    }
                    
                } catch (error) {
                    this.log('âŒ System status request failed: ' + error.message);
                }
            }
            
            clearLogs() {
                document.getElementById('consoleLogs').innerHTML = '';
                document.getElementById('networkActivity').innerHTML = '<div class="text-gray-500 text-center py-4">No network activity yet</div>';
                this.log('ðŸ§¹ Logs cleared');
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Initialize the test interface
        const testInterface = new VideoChunkManagerTest();
    </script>
</body>
</html>